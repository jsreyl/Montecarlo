#include<iostream>
#include<cmath>
#include "Random64.h"

const int L=8;
const int L2 = L*L;
const double kB = 1.0;

class SpinSystem{
private:
  int s[L][L], E, M; //La caja como un arreglo, la energía y la magnetización.
public:
  void InicieTodosAbajo(void);
  void UnPasoDeMetropolis(double Beta, Crandom & Ran64);//Beta en lugar de beta porque las variables reservadas de c++ empiezan con minúscula.
  double GetE(void){return E;};
  double GetM(void){return std::fabs(M);};
};

void SpinSystem::InicieTodosAbajo(void){
  for(int i=0; i<L;i++)
    for(int j=0; j<L;j++)
      s[i][j]=-1;
  M=-L2; E = -2*L2;
}

void SpinSystem::UnPasoDeMetropolis(double Beta, Crandom & Ran64){ // Miro la estructura de metrópolis y dependiendo del cambio de energía volteo.
  int n,i,j; double dE;
  //Escojo un spin al azar;
  n = (int) 16*Ran64.r();  i = n%L; j = n/L;
  //s[(n%L][n/L]; las columnas son lo que sobra y las filas es la división.
  //Calculo el dE que se produciría se lo volteo.
  //La energía entre spines es menos su producto punto e_12 = -s1.s2; si volteo el spin, el cambio en energía es 2e
  dE = 2*s[i][j]*(s[(i+1)%L][j]+s[(i+L-1)%L][j]+s[i][(j+1)%L]+s[i][(j+L-1)%L]);//Pues tengo 4 vecinos. Condiciones periódicas.
  if(dE<=0){
    //lo volteo;
    s[i][j]*=-1;
    E+=dE;
    M+=2*s[i][j]; //La magnetización en ese punto pasa de s a -s, luego después de voltearlo dM = -2s_antes = 2s_después.
  }  else if (Ran64.r()<std::exp(-Beta*dE)){
    //lo volteo;
    s[i][j]*=-1;
    E+=dE;
    M+=2*s[i][j];
  }
}


const int teq = (int)(600*pow(L/8.0,2.125));//El triple del tiempo de equilibrio, para que equilibre bien.
const int tcorr = (int)(50*pow(L/8.0,2.125));//El tiempo que pasa para que las muestras esten descorrelacionadas, i.e. que no se parezcan (pues una se construye a partir de las otras.)
const int Nmuestras = 10000;


int main(void){
  SpinSystem Ising;
  Crandom Ran64(1902); //Una semilla diferente a 0
  double kT, Beta;
  int mcs, mcss; //MonteCarlo step and Monte Carlo Step per Site.
  int teq; //Tiempo de equilibrio, realmente no es un tiempo sino un número de pasos para que la distribución llegue a equilibrio.
  double E,M, sumM, sumM2, sumM4, sumE, sumE2; //Acumuladores, aquí van los valores de energía y magnetización.
  double Eprom, E2prom, Mprom, M2prom, M4prom;
  double Cv, Xs, Ubinder; //Las cantidades que quiero calcular, capacidad calorífica, suceptibilidad, cumulante de Binder.
  //Con el cumulante de Binder se halla la temeratura crítica.
  
  
  for(kT=0.8;kT<3;kT+=0.1){//Para cada temperatura
    //  kT = 2.2;
    Beta = 1.0/kT;
    //Inicio el sistema
    Ising.InicieTodosAbajo();
    //Dejo que el sistema llegue a equilibrio
    //Hago pasos de montecarlo por sitio hasta que el sistema no cambie
    for(mcss = 0; mcss<teq; mcss++)
      for(mcs=0; mcs<L2;mcs++)
	Ising.UnPasoDeMetropolis(Beta, Ran64);
    
    //Tomar N muestras
    //Inicio los acumuladores en cero
    sumM=sumM2=sumM4=sumE=sumE2 = 0.0;
    for(int cmuestras=0;cmuestras<Nmuestras;cmuestras++){
      //Tomo 1 Muestra
      E = Ising.GetE();
      M = Ising.GetM();
      sumM+=M; sumM2 +=M*M; sumM4+=M*M*M*M; sumE+=E; sumE2+=E*E;
      
      //Avanzar hasta la siguiente muestra, uso el tiempo de correlación
      for(mcss = 0; mcss<tcorr; mcss++)
	for(mcs=0; mcs<L2;mcs++)
	  Ising.UnPasoDeMetropolis(Beta, Ran64);
    }
  
    //Hacer los promedios
    Mprom=sumM/Nmuestras;  M2prom=sumM2/Nmuestras;  M4prom=sumM4/Nmuestras;  Eprom=sumE/Nmuestras;  E2prom=sumE2/Nmuestras;
    //Calculo las cantidades que quiero imprimir
    Cv = kB/(kT*kT)*(E2prom-Eprom*Eprom);
    Xs = Beta*(M2prom-Mprom*Mprom);
    Ubinder = 1.0-1.0/3*M4prom/(M2prom*M2prom);
  //Imprimir los resultados
  //std::cout<<"E="<<Ising.GetE()<<" , M="<<Ising.GetM()<<std::endl;
    std::cout<<kT<<" "<<Eprom<<" "<<Mprom<<" "<<Cv<<" "<<Xs<<" "<<Ubinder<<std::endl;
  }
  return 0;
}
